# --- FILE: .github/workflows/release-builder.yml (FINAL & FULLY ROBUST v3) ---
name: Build and Release Pre-compiled Libraries

# FIX FOR LINUX: Add permissions block to allow uploading to releases.
permissions:
  contents: write

on:
  release:
    types: [published]

jobs:
  build:
    name: Build for ${{ matrix.os_name }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            os_name: Linux
            artifact_name: libnewrllama_linux_x64.zip
            lib_name: libnewrllama.so
          - os: windows-latest
            os_name: Windows
            artifact_name: newrllama_windows_x64.zip
            lib_name: newrllama.dll
          - os: macos-13
            os_name: macOS (Intel)
            artifact_name: libnewrllama_macos_x64.zip
            lib_name: libnewrllama.dylib
          - os: macos-14
            os_name: macOS (Apple Silicon)
            artifact_name: libnewrllama_macos_arm64.zip
            lib_name: libnewrllama.dylib

    runs-on: ${{ matrix.os }}

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: 'recursive'

    # --- Platform-specific dependency installation ---
    - name: Install dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake curl libcurl4-openssl-dev

    # FIX FOR WINDOWS v1.0.21: Use PowerShell for better path handling
    - name: Setup vcpkg and install curl (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        Write-Host "##[group]Setting up vcpkg and installing curl..."
        Set-Location $env:GITHUB_WORKSPACE
        git clone https://github.com/microsoft/vcpkg.git vcpkg
        Set-Location vcpkg
        .\bootstrap-vcpkg.bat
        .\vcpkg.exe install curl:x64-windows-static
        $vcpkgRoot = Join-Path $env:GITHUB_WORKSPACE "vcpkg"
        Write-Host "VCPKG_ROOT=$vcpkgRoot"
        "VCPKG_ROOT=$vcpkgRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        Write-Host "##[endgroup]"

    # --- Inject our custom files ---
    - name: Copy custom files to llama.cpp directory
      shell: bash
      run: |
        echo "Copying custom C-API and CMake files..."
        cp custom_files/newrllama_capi.h backend/llama.cpp/
        cp custom_files/newrllama_capi.cpp backend/llama.cpp/
        cp custom_files/CMakeLists.txt.custom backend/llama.cpp/CMakeLists.txt
        
        # Copy symbol verification script
        echo "Copying symbol verification script..."
        cp scripts/check_symbols.sh backend/llama.cpp/
        chmod +x backend/llama.cpp/check_symbols.sh

    # --- Configure and Build ---
    - name: Configure and Build
      shell: bash
      run: |
        cd backend/llama.cpp
        mkdir build && cd build

        # Base CMake arguments
        CMAKE_ARGS="-DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=OFF"
        
        # Platform-specific arguments
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          # Convert Windows path separators for CMake
          VCPKG_CMAKE_PATH=$(echo "$VCPKG_ROOT" | sed 's|\\|/|g')/scripts/buildsystems/vcpkg.cmake
          CMAKE_ARGS="$CMAKE_ARGS -DCMAKE_TOOLCHAIN_FILE=\"$VCPKG_CMAKE_PATH\" -DVCPKG_TARGET_TRIPLET=x64-windows-static"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then
          CMAKE_ARGS="$CMAKE_ARGS -DLLAMA_ACCELERATE=ON -DLLAMA_METAL=ON"
        else # Linux
          CMAKE_ARGS="$CMAKE_ARGS -DLLAMA_ACCELERATE=ON"
        fi
        
        echo "Configuring with CMake: $CMAKE_ARGS"
        cmake .. $CMAKE_ARGS
        
        echo "Building target 'newrllama'..."
        # CRITICAL FIX for Windows: Use /m for MSBuild, -j for make/ninja
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          cmake --build . --config Release --target newrllama --verbose -- /m:2
        else
          cmake --build . --config Release --target newrllama --verbose -- -j 2
        fi
        
    # --- GLUE-CODE ARCHITECTURE: Verify static library symbol completeness ---
    - name: Verify Static Library Symbols
      shell: bash
      run: |
        cd backend/llama.cpp
        echo "üîç Running symbol verification for glue-code architecture..."
        echo "üìä Platform: ${{ runner.os }} (${{ matrix.os_name }})"
        
        # Run our symbol verification script
        if ./check_symbols.sh build; then
          echo "‚úÖ Static libraries contain all required symbols - glue-code architecture is working!"
          echo "üéØ This platform may be able to use pure static library linking in the future."
        else
          echo "‚ö†Ô∏è  Some symbols missing from static libraries."
          echo "üîß OBJECT library fallback strategy will handle the missing symbols."
          echo "üìà Platform-specific analysis:"
          case "${{ runner.os }}" in
            "Linux")
              echo "    Linux often has symbols in libllama.a but missing from libggml.a"
              ;;
            "macOS") 
              echo "    macOS typically needs OBJECT library fallback due to framework integration"
              ;;
            "Windows")
              echo "    Windows may have different symbol distribution across static libraries"
              ;;
          esac
          echo "    The build will continue with OBJECT library strategy."
        fi

    # --- Package and Upload ---
    - name: Package the artifact
      shell: bash
      run: |
        # Create a temporary 'staging' directory for packaging.
        mkdir -p staging/lib
        
        # Find the actual location of the compiled library
        echo "üîç Searching for compiled library..."
        find backend/llama.cpp/build -name "*newrllama*" -type f
        
        # Define the path to the compiled library based on platform and actual location
        if [[ "${{ runner.os }}" == "Windows" ]]; then
          # Check multiple possible locations for Windows
          if [[ -f "backend/llama.cpp/build/bin/Release/${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/bin/Release/${{ matrix.lib_name }}"
          elif [[ -f "backend/llama.cpp/build/Release/${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/Release/${{ matrix.lib_name }}"
          elif [[ -f "backend/llama.cpp/build/${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/${{ matrix.lib_name }}"
          else
            echo "‚ùå Cannot find Windows library file"
            find backend/llama.cpp/build -name "*.dll" -type f
            exit 1
          fi
        else
          # Check multiple possible locations for Unix-like systems
          if [[ -f "backend/llama.cpp/build/bin/${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/bin/${{ matrix.lib_name }}"
          elif [[ -f "backend/llama.cpp/build/${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/${{ matrix.lib_name }}"
          elif [[ -f "backend/llama.cpp/build/lib${{ matrix.lib_name }}" ]]; then
            LIB_PATH="backend/llama.cpp/build/lib${{ matrix.lib_name }}"
          else
            echo "‚ùå Cannot find Unix library file"
            find backend/llama.cpp/build -name "*.so" -o -name "*.dylib" -type f
            exit 1
          fi
        fi

        # Verify the library file exists and copy it
        echo "üìÅ Using library path: $LIB_PATH"
        if [[ -f "$LIB_PATH" ]]; then
          echo "‚úÖ Library file found, copying to staging/lib/"
          cp "$LIB_PATH" staging/lib/
          echo "üìä Library info:"
          ls -la staging/lib/
          file staging/lib/*
        else
          echo "‚ùå Library file not found at: $LIB_PATH"
          exit 1
        fi

        # Create the zip archive.
        echo "üì¶ Creating zip archive: ${{ matrix.artifact_name }}"
        cd staging
        zip -r ../${{ matrix.artifact_name }} .
        cd ..

    - name: Upload Artifact to Release
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./${{ matrix.artifact_name }}
        asset_name: ${{ matrix.artifact_name }}
        asset_content_type: application/zip